<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Bridge Card Builder</title>
  <style>
    :root { color-scheme: dark; }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background: #0f1115;
      color: #e8ecf2;
    }
    .app {
      display: grid;
      grid-template-columns: 360px 1fr;
      gap: 16px;
      height: 100vh;
      padding: 16px;
      box-sizing: border-box;
    }
    .panel {
      background: #141826;
      border: 1px solid #232a3a;
      border-radius: 14px;
      padding: 14px;
      box-sizing: border-box;
    }
    h1 {
      font-size: 16px;
      margin: 0 0 10px 0;
      letter-spacing: 0.2px;
    }
    label {
      display: block;
      font-size: 12px;
      opacity: 0.9;
      margin: 10px 0 6px;
    }
    input[type="text"], select {
      width: 100%;
      box-sizing: border-box;
      padding: 10px 10px;
      border-radius: 10px;
      border: 1px solid #2a3246;
      background: #0f1320;
      color: #e8ecf2;
      outline: none;
    }
    .row {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }
    .checks {
      display: grid;
      grid-template-columns: 1fr;
      gap: 8px;
      margin-top: 10px;
    }
    .check {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 13px;
      opacity: 0.95;
      user-select: none;
    }
    .buttons {
      display: grid;
      grid-template-columns: 1fr;
      gap: 10px;
      margin-top: 12px;
    }
    button {
      cursor: pointer;
      border: 1px solid #2a3246;
      background: #1a2140;
      color: #e8ecf2;
      padding: 10px 12px;
      border-radius: 12px;
      font-weight: 600;
    }
    button:hover { filter: brightness(1.08); }
    .muted {
      font-size: 12px;
      line-height: 1.35;
      opacity: 0.75;
      margin-top: 10px;
      white-space: pre-line;
    }
    .previewWrap {
      display: grid;
      grid-template-rows: auto 1fr auto;
      gap: 10px;
    }
    .canvasWrap {
      background: #0b0d12;
      border: 1px solid #232a3a;
      border-radius: 14px;
      padding: 10px;
      display: grid;
      place-items: center;
      overflow: hidden;
    }
    canvas {
      max-width: 100%;
      max-height: calc(100vh - 180px);
      border-radius: 12px;
      background: #0b0d12;
    }
    .status {
      font-size: 12px;
      opacity: 0.75;
      overflow-wrap: anywhere;
    }
    .fileRow {
      display: grid;
      grid-template-columns: 1fr;
      gap: 10px;
    }
    input[type="file"] {
      width: 100%;
      box-sizing: border-box;
      padding: 10px;
      border-radius: 10px;
      border: 1px dashed #2a3246;
      background: #0f1320;
      color: #cfd6e4;
    }
  </style>
</head>
<body>
  <div class="app">
    <div class="panel">
      <h1>Card Settings</h1>

      <label for="title">Title (kept inside SAFE)</label>
      <input id="title" type="text" value="CHOSEN OF THE MOON" />

      <label for="cardType">Card Type</label>
      <select id="cardType"></select>

      <label for="subType">Subtype (loads border layer)</label>
      <select id="subType"></select>

      <label for="fontSel">Font</label>
      <select id="fontSel"></select>

      <div class="checks">
        <label class="check"><input id="showGuides" type="checkbox" checked /> Show guides in preview</label>
        <label class="check"><input id="exportGuides" type="checkbox" /> Export guides (usually OFF)</label>
        <label class="check"><input id="showReference" type="checkbox" /> Show reference overlay</label>
      </div>

      <label>Border Layer (PNG, transparent recommended)</label>
      <div class="fileRow">
        <input id="borderFile" type="file" accept="image/png,image/webp,image/jpeg" />
      </div>

      <div class="buttons">
        <button id="exportBtn">Export PNG (BLEED 747×1122)</button>
      </div>

      <div class="muted" id="rulesText"></div>
    </div>

    <div class="panel previewWrap">
      <h1>Live Preview</h1>
      <div class="canvasWrap">
        <canvas id="preview" width="747" height="1122"></canvas>
      </div>
      <div class="status" id="status"></div>
    </div>
  </div>

<script>
(() => {
  // --------------------------
  // Baked template constants
  // --------------------------
  const DPI = 300;
  const BLEED = { w: 747, h: 1122 };     // 2.49" x 3.74" @ 300dpi
  const CUT   = { w: 675, h: 1050 };     // 2.25" x 3.50"
  const SAFE  = { w: 615, h: 990  };     // 2.05" x 3.30"

  const CUT0  = { x: Math.floor((BLEED.w - CUT.w) / 2),  y: Math.floor((BLEED.h - CUT.h) / 2) };
  const SAFE0 = { x: Math.floor((BLEED.w - SAFE.w) / 2), y: Math.floor((BLEED.h - SAFE.h) / 2) };

  const CUT1  = { x: CUT0.x + CUT.w,  y: CUT0.y + CUT.h };
  const SAFE1 = { x: SAFE0.x + SAFE.w, y: SAFE0.y + SAFE.h };

  // --------------------------
  // Types & subtypes
  // --------------------------
  const CARD_TYPES = ["Roll Phase", "Ability Upgrade", "Other"];
  const SUBTYPES = {
    "Roll Phase": ["Blue", "Red", "Orange"],
    "Ability Upgrade": ["Standard Ability", "Passive Ability", "Defensive Ability"],
    "Other": []
  };

  // Fallback background colors (behind border)
  const BG = {
    "Blue": "rgba(11,15,22,1)",
    "Red": "rgba(18,9,10,1)",
    "Orange": "rgba(18,13,6,1)",
    "Standard Ability": "rgba(16,18,21,1)",
    "Passive Ability": "rgba(14,9,20,1)",
    "Defensive Ability": "rgba(7,18,10,1)",
    "Other": "rgba(10,12,16,1)"
  };

  // Basic font list (browser-installed); you can extend anytime
  const FONT_CHOICES = [
    "system-ui",
    "Segoe UI",
    "Arial",
    "Verdana",
    "Georgia",
    "Trebuchet MS",
    "Times New Roman",
    "Impact"
  ];

  // --------------------------
  // DOM refs
  // --------------------------
  const elTitle = document.getElementById("title");
  const elCardType = document.getElementById("cardType");
  const elSubType = document.getElementById("subType");
  const elFont = document.getElementById("fontSel");
  const elShowGuides = document.getElementById("showGuides");
  const elExportGuides = document.getElementById("exportGuides");
  const elShowReference = document.getElementById("showReference");
  const elBorderFile = document.getElementById("borderFile");
  const elExportBtn = document.getElementById("exportBtn");
  const elRulesText = document.getElementById("rulesText");
  const elStatus = document.getElementById("status");

  const canvas = document.getElementById("preview");
  const ctx = canvas.getContext("2d");

  // Offscreen master canvas (always bleed size)
  const master = document.createElement("canvas");
  master.width = BLEED.w;
  master.height = BLEED.h;
  const mctx = master.getContext("2d");

  // Border image storage (per subtype)
  const borderImages = new Map(); // key=subtype, value=Image()

  // Reference overlay image (single)
  const referenceImg = new Image();
  // preload a reference image from the project's Assets/Reference folder (if present)
  referenceImg.src = "Assets/Reference/Roll_Phase_Main_Refernece.png";

  // Current state
  const state = {
    title: elTitle.value,
    cardType: "Roll Phase",
    subType: "Blue",
    font: "Segoe UI",
    showGuides: true,
    exportGuides: false,
    showReference: false,
  };

  // --------------------------
  // Helpers
  // --------------------------
  function setOptions(select, values) {
    select.innerHTML = "";
    values.forEach(v => {
      const opt = document.createElement("option");
      opt.value = v;
      opt.textContent = v;
      select.appendChild(opt);
    });
  }

  function dashedRect(context, x, y, w, h, dash=14, gap=10) {
    context.save();
    context.setLineDash([dash, gap]);
    context.strokeRect(x + 0.5, y + 0.5, w, h); // 0.5 for crisp lines
    context.restore();
  }

  function drawGuides(context) {
    // Bleed (blue) - outer
    context.save();
    context.lineWidth = 3;
    context.strokeStyle = "rgba(60,140,255,1)";
    context.strokeRect(1.5, 1.5, BLEED.w - 3, BLEED.h - 3);
    context.restore();

    // Cut (black)
    context.save();
    context.lineWidth = 3;
    context.strokeStyle = "rgba(0,0,0,1)";
    context.strokeRect(CUT0.x + 1.5, CUT0.y + 1.5, CUT.w - 3, CUT.h - 3);
    context.restore();

    // Safe (red dashed)
    context.save();
    context.lineWidth = 3;
    context.strokeStyle = "rgba(255,60,60,1)";
    dashedRect(context, SAFE0.x + 1.5, SAFE0.y + 1.5, SAFE.w - 3, SAFE.h - 3);
    context.restore();
  }

  function shrinkToFit(text, maxWidthPx, baseSize, fontFamily, weight="700") {
    let size = baseSize;
    while (size > 16) {
      mctx.font = `${weight} ${size}px "${fontFamily}"`;
      const w = mctx.measureText(text).width;
      if (w <= maxWidthPx) break;
      size -= 2;
    }
    return size;
  }

  // --------------------------
  // Rendering (master -> preview)
  // --------------------------
  function renderMaster(includeGuides) {
    // Background
    const bg = BG[state.subType] || "rgba(10,12,16,1)";
    mctx.clearRect(0, 0, BLEED.w, BLEED.h);
    mctx.fillStyle = bg;
    mctx.fillRect(0, 0, BLEED.w, BLEED.h);

    // Header band (inside SAFE)
    const headerH = Math.floor(SAFE.h * 0.12);
    const hx0 = SAFE0.x;
    const hy0 = SAFE0.y;
    const hx1 = SAFE1.x;
    const hy1 = Math.min(SAFE1.y, SAFE0.y + headerH);

    mctx.fillStyle = "rgba(0,0,0,0.45)";
    mctx.fillRect(hx0, hy0, hx1 - hx0, hy1 - hy0);

    // Title (clamped to SAFE)
    const title = (state.title || "UNTITLED").trim().toUpperCase();
    const maxTitleW = SAFE.w - 24;
    const baseSize = Math.floor(SAFE.h * 0.045); // similar to python version
    const size = shrinkToFit(title, maxTitleW, Math.min(54, Math.max(28, baseSize)), state.font, "800");

    mctx.font = `800 ${size}px "${state.font}"`;
    mctx.fillStyle = "rgba(255,255,255,1)";
    mctx.textBaseline = "middle";
    mctx.textAlign = "center";
    const titleY = hy0 + (hy1 - hy0) / 2;
    mctx.fillText(title, SAFE0.x + SAFE.w / 2, titleY);

    // Placeholder content panel inside SAFE (safe margins)
    const bodyTop = hy1 + Math.floor(SAFE.h * 0.06);
    const bodyBot = SAFE1.y - Math.floor(SAFE.h * 0.06);
    const bodyLeft = SAFE0.x + Math.floor(SAFE.w * 0.06);
    const bodyRight = SAFE1.x - Math.floor(SAFE.w * 0.06);

    if (bodyRight > bodyLeft && bodyBot > bodyTop) {
      mctx.strokeStyle = "rgba(70,85,110,1)";
      mctx.lineWidth = 3;
      mctx.strokeRect(bodyLeft + 1.5, bodyTop + 1.5, (bodyRight - bodyLeft) - 3, (bodyBot - bodyTop) - 3);

      mctx.font = `600 28px "${state.font}"`;
      mctx.fillStyle = "rgba(210,220,235,1)";
      mctx.textAlign = "left";
      mctx.textBaseline = "top";
      mctx.fillText("(Rules text / icons go here)", bodyLeft + 16, bodyTop + 16);
    }

    // Border overlay for current subtype (if loaded)
    const borderImg = borderImages.get(state.subType);
    if (borderImg && borderImg.complete && borderImg.naturalWidth > 0) {
      mctx.drawImage(borderImg, 0, 0, BLEED.w, BLEED.h);
      elStatus.textContent = `Loaded border for "${state.subType}" (${borderImg.naturalWidth}×${borderImg.naturalHeight} → scaled to ${BLEED.w}×${BLEED.h}).`;
    } else {
      elStatus.textContent = `No border loaded for "${state.subType}". Choose a border PNG file to layer on top.`;
    }

    // Reference overlay (draw on top of border if enabled)
    if (state.showReference && referenceImg && referenceImg.complete && referenceImg.naturalWidth > 0) {
      mctx.save();
      mctx.globalAlpha = 0.65; // semi-transparent so underlying layers remain visible
      mctx.drawImage(referenceImg, 0, 0, BLEED.w, BLEED.h);
      mctx.restore();
      elStatus.textContent = elStatus.textContent + ` Reference overlay drawn.`;
    }

    // Guides last
    if (includeGuides) drawGuides(mctx);
  }

  function renderPreview() {
    renderMaster(state.showGuides);

    // Copy master to visible canvas (same size)
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.drawImage(master, 0, 0);
  }

  // --------------------------
  // Export
  // --------------------------
  function exportPNG() {
    renderMaster(state.exportGuides); // re-render with export toggle

    master.toBlob((blob) => {
      if (!blob) return;
      const a = document.createElement("a");
      const fileBase = (state.subType || "card").toLowerCase().replace(/\s+/g, "_");
      a.download = `${fileBase}_bleed_${BLEED.w}x${BLEED.h}.png`;
      a.href = URL.createObjectURL(blob);
      a.click();
      setTimeout(() => URL.revokeObjectURL(a.href), 1500);
    }, "image/png");
  }

  // --------------------------
  // Border loading
  // --------------------------
  function loadBorderForCurrentSubtype(file) {
    const img = new Image();
    img.onload = () => {
      borderImages.set(state.subType, img);
      renderPreview();
    };
    img.onerror = () => {
      alert("Failed to load image. Try a PNG with transparency.");
    };
    img.src = URL.createObjectURL(file);
  }

  // --------------------------
  // Init UI
  // --------------------------
  setOptions(elCardType, CARD_TYPES);
  setOptions(elFont, FONT_CHOICES);

  // Default selections
  elCardType.value = state.cardType;
  elFont.value = state.font;
  // reference checkbox follows state
  elShowReference.checked = state.showReference;

  function syncSubtypes() {
    const opts = SUBTYPES[state.cardType] || [];
    if (opts.length === 0) {
      setOptions(elSubType, ["Other"]);
      elSubType.value = "Other";
      elSubType.disabled = true;
      state.subType = "Other";
    } else {
      setOptions(elSubType, opts);
      elSubType.disabled = false;
      // keep if valid, else first
      if (!opts.includes(state.subType)) state.subType = opts[0];
      elSubType.value = state.subType;
    }
  }

  elRulesText.textContent =
`Template rules baked in (@ ${DPI} DPI):
BLEED: ${BLEED.w}×${BLEED.h}px (2.49"×3.74") — export canvas
CUT:   ${CUT.w}×${CUT.h}px (2.25"×3.50")
SAFE:  ${SAFE.w}×${SAFE.h}px (2.05"×3.30") — keep title/icons/text inside`;

  syncSubtypes();
  renderPreview();

  // --------------------------
  // Event wiring
  // --------------------------
  let renderTimer = null;
  function requestRender() {
    if (renderTimer) clearTimeout(renderTimer);
    renderTimer = setTimeout(renderPreview, 25);
  }

  elTitle.addEventListener("input", () => { state.title = elTitle.value; requestRender(); });
  elFont.addEventListener("change", () => { state.font = elFont.value; requestRender(); });

  elCardType.addEventListener("change", () => {
    state.cardType = elCardType.value;
    syncSubtypes();
    requestRender();
  });

  elSubType.addEventListener("change", () => {
    state.subType = elSubType.value;
    requestRender();
  });

  elShowGuides.addEventListener("change", () => { state.showGuides = elShowGuides.checked; requestRender(); });
  elExportGuides.addEventListener("change", () => { state.exportGuides = elExportGuides.checked; });
  elShowReference.addEventListener("change", () => { state.showReference = elShowReference.checked; requestRender(); });

  elBorderFile.addEventListener("change", () => {
    const file = elBorderFile.files?.[0];
    if (!file) return;
    loadBorderForCurrentSubtype(file);
    // clear input so you can re-select same file later if needed
    elBorderFile.value = "";
  });

  elExportBtn.addEventListener("click", exportPNG);
})();
</script>
</body>
</html>